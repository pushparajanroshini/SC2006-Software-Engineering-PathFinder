const axios = require('axios');
const cookie = "_toffsuid=rB8E8GYL5xNLXUnGBoCUAg==";
const data = {
  email: "YONG0257@e.ntu.edu.sg",
  password: "Sc2006sc2006"
};

let authorizationToken; // Declare the variable to store the token

axios.post('https://www.onemap.gov.sg/api/auth/post/getToken', data)
  .then(response => {
    // Extract the token from the response data
    authorizationToken = response.data.access_token;
    //console.log('Authorization Token:', authorizationToken); // Log the token
  })
  .catch(error => {
    // Handle error here
    console.error('Error:', error);
  });
  //const authorizationToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiI2YzBjY2Y5MWRjZDIwMGE1ODhjMzdmMjZlNjhiM2JlMCIsImlzcyI6Imh0dHA6Ly9pbnRlcm5hbC1hbGItb20tcHJkZXppdC1pdC0xMjIzNjk4OTkyLmFwLXNvdXRoZWFzdC0xLmVsYi5hbWF6b25hd3MuY29tL2FwaS92Mi91c2VyL3Nlc3Npb24iLCJpYXQiOjE3MTI0MTQ5NDAsImV4cCI6MTcxMjY3NDE0MCwibmJmIjoxNzEyNDE0OTQwLCJqdGkiOiJuR0RiUFlONE92MFFNOVBhIiwidXNlcl9pZCI6MzEzOCwiZm9yZXZlciI6ZmFsc2V9.K8R3o0pNnFBjxWU5kTo3akzLPiW7Cz7y8-CFtd8bUBQ";
  //const cookie = "_toffsuid=rB8E8GYL5xNLXUnGBoCUAg==";

////////////////////////////////////////////////////////////////

function fetchPTData(authorizationToken, cookie, startAddress, endAddress, routeType, date, time){
    let startCoordinates, endCoordinates; // Declare variables outside fetchData function

    const myHeaders = new Headers();
    myHeaders.append("Authorization", authorizationToken);
    myHeaders.append("Cookie", cookie);

    const requestOptions = {
        method: "GET",
        headers: myHeaders,
        redirect: "follow"
    };

    // Construct URLs for start and end address search (convert to coordinates)
    const startUrl = `https://www.onemap.gov.sg/api/common/elastic/search?searchVal=${encodeURIComponent(startAddress)}&returnGeom=Y&getAddrDetails=Y`;
    const endUrl = `https://www.onemap.gov.sg/api/common/elastic/search?searchVal=${encodeURIComponent(endAddress)}&returnGeom=Y&getAddrDetails=Y`;

    // Fetch start address data
    const startDataPromise = fetch(startUrl, requestOptions)
        .then((response) => response.json())
        .then((startResult) => {
            //console.log("Start Address Data:", startResult.results[0]);

        // extract latitude and longitude of start point
        startCoordinates = {
            latitude: parseFloat(startResult.results[0].LATITUDE),
            longitude: parseFloat(startResult.results[0].LONGITUDE)
        };
        //console.log("start coordinates:", startCoordinates);
        return startCoordinates; // Return the coordinates for chaining promises
        })
        .catch((error) => console.error("Error fetching start address data:", error));



    //fetch end address data
    const endDataPromise = fetch(endUrl, requestOptions)
        .then((response) => response.json())
        .then((endResult) => {
             //console.log("End Address Data:", endResult.results[0]);

             endCoordinates = {
                latitude: parseFloat(endResult.results[0].LATITUDE),
                longitude: parseFloat(endResult.results[0].LONGITUDE)
            };
            //console.log("end coordinates:", endCoordinates);
            return endCoordinates;

        })
        .catch((error) => console.error("Error fetching end address data:", error));

    //wait for both promises to resolve 
    Promise.all ([startDataPromise,endDataPromise])
        .then(([startCoordinates, endCoordinates]) => {
            // Construct the URL for routing
            const routeUrl = `https://www.onemap.gov.sg/api/public/routingsvc/route?start=${startCoordinates.latitude},${startCoordinates.longitude}&end=${endCoordinates.latitude},${endCoordinates.longitude}&routeType=${routeType}&date=${date}&time=${time}&mode=TRANSIT`;

            const routeHeaders = new Headers();
            routeHeaders.append("Authorization", authorizationToken);
            routeHeaders.append("Cookie", cookie);

            const routeRequestOptions = {
                method: "GET",
                headers: routeHeaders,
                redirect: "follow"
            };

            // Fetch route data
            fetch(routeUrl, routeRequestOptions)
            .then(response => response.json())
            .then((result) => {
                if (result.plan && result.plan.itineraries) {
                    // Sorting itineraries based on duration (fastest route first)
                    result.plan.itineraries.sort((a, b) => a.duration - b.duration);
    
                    // Sorting itineraries based on fare (cheapest route first)
                    result.plan.itineraries.sort((a, b) => a.fare - b.fare);
    
                    let fastestItinerary, cheapestItinerary;
                    let displayedItineraries = [];
    
                    // Iterate through itineraries to find fastest and cheapest
                    for (const itinerary of result.plan.itineraries) {
                        if (!fastestItinerary || itinerary.duration < fastestItinerary.duration) {
                            fastestItinerary = itinerary;
                        }
                        if (!cheapestItinerary || itinerary.fare < cheapestItinerary.fare) {
                            cheapestItinerary = itinerary;
                        }
                    }
    
                    // Display fastest itinerary
                    if (fastestItinerary) {
                        console.log("Fastest Itinerary:");
                        displayItinerary(fastestItinerary);
                        displayedItineraries.push(fastestItinerary);
                    }
    
                    // Display cheapest itinerary
                    if (cheapestItinerary) {
                        console.log("Cheapest Itinerary:");
                        displayItinerary(cheapestItinerary);
                        displayedItineraries.push(cheapestItinerary);
                    }
    
                    // Display remaining itineraries
                    for (const itinerary of result.plan.itineraries) {
                        if (!displayedItineraries.includes(itinerary)) {
                            console.log("Alternative Itinerary:");
                            displayItinerary(itinerary);
                        }
                    }
                } else {
                    console.log("No itineraries found.");
                }
            })
                
                .catch(error => console.error(error));
        });
}

function displayItinerary(itinerary) {
    console.log("Duration (minutes):", Math.round(itinerary.duration / 60)); // Convert duration to minutes
    console.log("Fare:", itinerary.fare);
    console.log("Modes of Transport:");
    itinerary.legs.forEach((leg, legIndex) => {
        console.log(`Leg ${legIndex + 1}:`);
        console.log("Mode:", leg.mode);
        console.log("Bus Number:", leg.route || "N/A"); // If route is not available, display N/A
        console.log("From:", leg.from.name);
        if (leg.mode === "BUS") {
            console.log("Next Bus Arrival Time:", formatTime(leg.from.arrival)); // Display bus arrival time only if mode is bus
        }
        console.log("To:", leg.to.name);
    });
}


function formatTime(timestamp) {
    const date = new Date(timestamp);
    const hours = date.getHours().toString().padStart(2, '0'); // Zero-padded hours
    const minutes = date.getMinutes().toString().padStart(2, '0'); // Zero-padded minutes
    const seconds = date.getSeconds().toString().padStart(2, '0'); // Zero-padded seconds
    return `${hours}:${minutes}:${seconds}`; // Return the formatted time
}
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.question('Enter start address: ', (startAddress) => {
    rl.question('Enter end address: ', (endAddress) => {
        rl.question('Enter date (MM-DD-YYYY): ', (date) => {
            rl.question('Enter time (HHMMSS): ', (time) => {
                const routeType = "pt";
                fetchPTData(authorizationToken, cookie, startAddress, endAddress, routeType, date, time);
                rl.close();
            });
        });
    });
});